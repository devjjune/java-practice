# java-practice-calculator

<br>

## 소개
- 입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다. 
- 학습 목표: 프리코스 1주차에 구현했던 계산기에 객체지향과 MVC 구조의 개념을 도입한다.

<br>

## 기능 요구 사항
1. 문자열을 입력받는다.
    - 입력받은 문자열을 저장한다.
    - 문자열을 구분자를 기준으로 분리한다. 
      - 기본 구분자: 쉼표(,)와 콜론(:)
      - 커스텀 구분자: 사용자가 지정. //와 \n 사이에 위치하는 문자
      1) 기본 구분자만 있는 경우
      2) 커스텀 구분자만 있는 경우
      3) 기본 구분자 + 커스텀 구분자 둘 다 있는 경우
      4) 구분자가 아예 없는 경우
2. 숫자를 추출한다.
3. 숫자의 합을 반환하여 출력한다. 

<br>

## 예외 사항
- 사용자가 잘못된 값을 입력할 경우: `IllegalArgumentException`을 발생시킨 후 애플리케이션 종료
  - 구분자와 양수 외의 문자가 포함된 경우
  - 커스텀 문자가 2개 이상인 경우

<br>

## 회고
### 💥 StringSplitterTest 에러 해결
커스텀 구분자를 기준으로 문자열을 분리하는 테스트를 실행했는데, `//`까지 함께 문자열로 분리되는 에러가 발생했다.   
처음에는 `//`를 제외하는 로직을 추가해야 하나 고민했지만, 요구사항을 다시 확인하면서 `//(커스텀 구분자)\n` 형태의 **선언부는 문자열 맨 앞에만 온다**는 조건을 놓쳤다는 걸 알게 됐다.   
즉, 원인은 분리 로직 자체가 아니라 **입력 형식 요구사항을 누락한 것**이었다.

### 🧩 public과 private의 기준
멤버 변수나 메서드에 대해 어디까지 private으로 숨길지, 혹은 private을 너무 과하게 사용하는 건 아닌지 고민했다.  
멤버 변수와 메서드를 private으로 선언하면, **외부에서 멤버 변수의 값이 필요할 경우 getter를 제공**할 수 있다.    
**private 메서드**는 외부에서 직접 호출할 수 없기 때문에,
필요에 따라 **생성자나 public 메서드를 통해 클래스 내부에서 호출**하도록 설계해야 한다.  

### 🧩 언제 static을 사용할까?
`static`은 멤버 변수나 메서드를 클래스에 종속시킬 때 사용한다.  
**상태 없는 유틸성 클래스**인 경우 `static`을 사용하는 게 더 자연스럽다.   
_(상태를 가지지 않는다: 객체 내부에서 값을 저장하지 않고, 단순히 값을 입력받고 처리해서 반환하는 기능만을 수행한다)_   
`static`이 불리한 경우: 상태를 내부 필드에 저장해야 할 때, 객체마다 다른 상태/데이터를 가져야 할 때

### 🧩 split() 정규식 문법
- 공백 사용에 주의해야 한다.  
  `input.split(", | :");`라고 쓰는 경우 공백까지 구분자에 포함되므로 `input.split("[,:]");` 또는 `input.split(",|:");`라고 써야 한다. 
- split() 안에 변수명을 그대로 쓰면 안 된다.   
  정규식은 문자열이므로 변수명을 그대로 쓰면 변수명이 아니라 리터럴 텍스트(문자 그대로의 값)로 읽힌다.  
  변수를 넣고 싶으면 문자열 더하기가 필요하다. `input.split(",|;|" + customDelimiter);`
- 정규식에 변수가 들어갈 때, 에러를 방지하기 위해 무조건 `Pattern.quote()`를 붙이자.  
  예) `numbersPart.split(",|:|" + Pattern.quote(customDelimiter));`

### 🧩 테스트 코드 활용 : 개발 과정의 일부로
**단위 테스트**는 버그를 사전에 발견하고 리팩토링을 용이하게 한다는 장점이 있다.    
하지만 그동안은 개발 도중 테스트를 작성하는 것이 부담스러워서 모든 코드 작성을 마친 뒤에 테스트 코드를 작성했고, 
따라서 테스트 코드를 유의미하게 사용하지 못했다.   
그러나, 이번에는 **메서드에 단위 테스트를 바로 바로 적용하며 더 완성도 있는 코드**를 작성할 수 있었다.   
**에러를 조기에 발견할 뿐 아니라, 수정하는 과정에서도 기존 로직이 깨지지 않는지 계속해서 검증**할 수 있었다.   

### 🧩 테스트 코드 작성법


