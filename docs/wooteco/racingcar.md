# java-practice-racingcar

<br>

## 소개
- 각 자동차별로 무작위 값을 추출해 이동할 칸 수를 누적한다. 입력받은 횟수만큼 반복해서 우승자를 선정한다. 
- 학습 목표: 프리코스 2주차에 구현했던 자동차 경주 게임에 객체지향과 MVC 개념을 도입해 리팩토링한다. 

<br>

## 기능 요구 사항
1. 입력
- 이름 입력 안내 문구 → 자동차 이름 입력
- 횟수 입력 안내 문구 → 시도할 횟수 입력

2. 실행
- 한 명씩 무작위 값을 반환 → 0-9 사이, 4 이상이면 1점을 더함
- 총 횟수만큼 반복

3. 출력
- 차수별 실행 결과 출력
- 단독 or 공동 우승자 출력
- 공동 우승자의 경우 쉼표를 이용해 구분

<br>

## 객체 중심으로 기능 재구성
#### 1. 도메인
- **Car**
  - 필드: `name`, `position`
  - 기능: 숫자를 전달받아 전진 조건(4 이상)에 맞으면 위치를 1 증가시킨다.  
- **Cars**
  - 필드: `List<Car>`
  - 기능: 모든 자동차에게 동시에 이동하라고 명령한다. 
  - 기능: 현재 자동차들 중 가장 멀리 간 위치(Max Position)을 구한다. 
- **NumberGenerator**
  - 기능: 0-9 사이의 무작위 숫자를 하나 생성하여 반환한다.
- **WinnerCalculator**
  - 기능: Cars로부터 자동차 목록을 받아 우승자 명단을 추출한다. 

#### 2. 입출력
- InputView: 이름 입력받기, 횟수 입력받기
- OutputView: 회차별 결과 출력, 우승자 출력

#### 3. 컨트롤러
- 전체 게임 흐름 제어 : 입력 받기 -> 자동차 생성 -> 시도 횟수만큼 반복 -> 결과 출력 -> 우승자 산출 -> 우승자 출력

<br>

## 예외 사항
- 사용자가 잘못된 값을 입력 → `IllegalArgumentException` 발생시킨 후 애플리케이션 종료
  - 공백을 입력한 경우
  - 이름을 5자보다 길게 입력한 경우
  - 한 명만 입력한 경우
  - 횟수에 0 이하의 수를 입력한 경우

<br>

## 회고
### 🎨 설계의 출발점: 'How'에서 'Who'로
이전에는 기능 요구 사항을 게임의 흐름에 따라 나열하다 보니, 
자연스럽게 순서에 의존하는 절차 지향적 코드가 작성되었다.  

그러나 객체지향적인 설계를 위해선 **무엇을 할까(How)가 아니라 **누가 있을까(Who)에서 출발**해야 한다.   
동작 중심(동사)의 사고에서 벗어나 어떤 배역이 필요할지 명사(객체) 위주로 고민하고, 
각 객체에 책임을 분배한다.   
"이 일을 누가 하는 게 가장 자연스러운가?"를 기준으로 삼는다.  

### 🎨 객체 역할 분배 시 주의할 점
이전까진 객체가 아니라 데이터 중심으로 코드를 작성했다.   
**데이터를 가져와서(get) 밖에서 처리하지 말고, 데이터를 가진 객체에게 일을 시키자**  

### 🎨 객체의 두 종류 : 상태가 필요한 객체 vs 행위만 필요한 객체
전자는 기억해야 하는 상태가 존재하고, 후자는 유틸성 클래스로 잠깐 쓰는 도구이다.   
  
이전까진 모든 클래스에 필드를 선언해 데이터 중심 로직이 되었는데, **상태가 필요한 객체에만 필드를 넣는 것이 좋다.**  
특히 자동차 이름과 위치를 맵으로 묶은 데이터 대신, 이름과 위치를 필드로 가지는 자동차 객체를 만들었더니 구조가 깔끔해졌다. 

### 🎨 Service 클래스는 반드시 필요할까?
서비스 클래스는 무조건 있어야 한다고 생각했는데, 단순히 순서만 조립하는 역할이라면 controller만 있어도 된다.   
비즈니스 로직이 복잡할 때(예: 데이터베이스 저장, 외부 API 호출, 여러 도메인 객체의 상호작용)는 서비스를 사용하는 것이 좋다. 

### 🎨 접근 제어자는 언제, 어떻게 정하는 것이 좋을까?
> 접근 제어자는 코드 작성 시점에 바로바로 정하는 것이 좋다. 
> 일단 `private`으로 막고 시작, 이 기능을 외부에서 불러서 써야 한다는 확신이 들 때만 `public`으로 변경
 
**1) 필드(name, position): `private`**  
외부에서 직접 값을 수정하면 객체의 데이터가 오염된다.

**2) 생성자: `public`**  
밖에서 객체를 만들어야 한다.  

**3) 외부 명령용 메서드: `public`**  
movePosition, getName 등 외부 클래스가 시켜야 하는 일   

**4) 내부 계산용 메서드: `private`**  
클래스 안에서 자기들끼리만 쓰는 복잡한 계산 로직

### 🎨 생성자가 반드시 필요한 경우
> 필수적인 데이터 없이 객체가 제 기능을 할 수 없다면, 
> 반드시 생성자를 통해 그 데이터를 받아서 객체를 완성된 상태로 탄생시켜야 한다.
#### 이유: 
- 객체의 무결성 보장: 객체가 생성된 이후에 별도의 메서드로 초기화해야하는 구조는, 호출을 잊었을 때 에러가 발생할 수 있다. 
- 불변성(Final) 유지: 생성자에서 데이터를 주입받으면 필드에 final을 사용할 수 있어, 객체 생성 이후 데이터가 오염되는 것을 막을 수 있다.  

즉, **불완전한 객체가 돌아다니지 않도록 사전에 방지**하는 것이다. 
